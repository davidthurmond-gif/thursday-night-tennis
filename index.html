const API_KEY = ""; // optional: set to a secret string
const SHEET_APPROVED = "Approved";
const SHEET_PENDING  = "Pending";

function doGet(e) {
  const action = (e.parameter.action || "").toLowerCase();
  const key = e.parameter.key || "";
  if (API_KEY && key !== API_KEY) return json({ ok:false, error:"Unauthorized" });

  if (action === "dump") {
    return json({
      ok:true,
      approved: approvedAsObject_(),
      pending: pendingAsArray_(),
      meta: { serverTime: Date.now() }
    });
  }

  return json({ ok:false, error:"Unknown action" });
}

function doPost(e) {
  const body = safeJsonParse_(e.postData && e.postData.contents);
  const action = (body.action || "").toLowerCase();
  const key = body.key || "";
  if (API_KEY && key !== API_KEY) return json({ ok:false, error:"Unauthorized" });

  if (action === "submit") {
    submitPending_(body);
    return json({ ok:true });
  }

  if (action === "approve") {
    approve_(body.submissionId);
    return json({ ok:true });
  }

  if (action === "reject") {
    reject_(body.submissionId);
    return json({ ok:true });
  }

  if (action === "upsertapproved") {
    upsertApproved_(body.matchKey, body.record);
    return json({ ok:true });
  }

  if (action === "deleteapproved") {
    deleteApproved_(body.matchKey);
    return json({ ok:true });
  }

  if (action === "resetapproved") {
    resetApproved_();
    return json({ ok:true });
  }

  return json({ ok:false, error:"Unknown action" });
}

/* ---------------- Sheets ---------------- */

function shApproved_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(SHEET_APPROVED);
  if (!sh) sh = ss.insertSheet(SHEET_APPROVED);
  const headers = ["matchKey","type","a","b","aSets","bSets","pairsJson","ts"];
  ensureHeader_(sh, headers);
  return sh;
}

function shPending_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(SHEET_PENDING);
  if (!sh) sh = ss.insertSheet(SHEET_PENDING);
  const headers = ["id","matchKey","type","round","date","stage","a","b","pairsJson","submittedBy","submittedAt","status"];
  ensureHeader_(sh, headers);
  return sh;
}

function ensureHeader_(sh, headers) {
  if (sh.getLastRow() === 0) sh.appendRow(headers);
  const existing = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const existingSet = new Set(existing.filter(String));
  // If headers differ (older sheet), rewrite row 1 to expected structure
  const needsRewrite = headers.some((h,i)=>existing[i] !== h);
  if (needsRewrite) {
    sh.clear();
    sh.appendRow(headers);
  }
}

/* ---------------- Approved ---------------- */

function approvedAsObject_() {
  const sh = shApproved_();
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return {};
  const idx = index_(values[0]);
  const out = {};
  for (let r=1; r<values.length; r++) {
    const row = values[r];
    const matchKey = row[idx.matchKey];
    if (!matchKey) continue;
    out[matchKey] = {
      type: row[idx.type] || "regular",
      a: Number(row[idx.a]),
      b: Number(row[idx.b]),
      aSets: Number(row[idx.aSets]),
      bSets: Number(row[idx.bSets]),
      pairs: safeJsonParse_(row[idx.pairsJson] || "[]") || [],
      ts: Number(row[idx.ts]) || 0
    };
  }
  return out;
}

function upsertApproved_(matchKey, record) {
  if (!matchKey) throw new Error("matchKey required");
  const sh = shApproved_();
  const values = sh.getDataRange().getValues();
  const idx = index_(values[0]);

  const rowData = [
    matchKey,
    record.type || "regular",
    Number(record.a),
    Number(record.b),
    Number(record.aSets),
    Number(record.bSets),
    JSON.stringify(record.pairs || []),
    Number(record.ts) || Date.now()
  ];

  let foundRow = -1;
  for (let r=1; r<values.length; r++) {
    if (values[r][idx.matchKey] === matchKey) { foundRow = r+1; break; }
  }

  if (foundRow === -1) sh.appendRow(rowData);
  else sh.getRange(foundRow,1,1,rowData.length).setValues([rowData]);
}

function deleteApproved_(matchKey) {
  if (!matchKey) return;
  const sh = shApproved_();
  const values = sh.getDataRange().getValues();
  const idx = index_(values[0]);
  for (let r=values.length-1; r>=1; r--) {
    if (values[r][idx.matchKey] === matchKey) { sh.deleteRow(r+1); return; }
  }
}

function resetApproved_() {
  const sh = shApproved_();
  const last = sh.getLastRow();
  if (last > 1) sh.deleteRows(2, last-1);
}

/* ---------------- Pending ---------------- */

function pendingAsArray_() {
  const sh = shPending_();
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return [];
  const idx = index_(values[0]);
  const out = [];
  for (let r=1; r<values.length; r++) {
    const row = values[r];
    if (!row[idx.id]) continue;
    if ((row[idx.status] || "PENDING") !== "PENDING") continue;
    out.push({
      id: String(row[idx.id]),
      matchKey: String(row[idx.matchKey]),
      type: row[idx.type] || "regular",
      round: Number(row[idx.round] || 0),
      date: row[idx.date] || "",
      stage: row[idx.stage] || "",
      a: Number(row[idx.a]),
      b: Number(row[idx.b]),
      pairs: safeJsonParse_(row[idx.pairsJson] || "[]") || [],
      submittedBy: row[idx.submittedBy] || "",
      submittedAt: Number(row[idx.submittedAt]) || 0
    });
  }
  // newest first
  out.sort((x,y)=>(y.submittedAt||0)-(x.submittedAt||0));
  return out;
}

function submitPending_(body) {
  const sh = shPending_();
  const id = Utilities.getUuid();
  const row = [
    id,
    body.matchKey || "",
    body.type || "regular",
    body.round || "",
    body.date || "",
    body.stage || "",
    Number(body.a),
    Number(body.b),
    JSON.stringify(body.pairs || []),
    body.submittedBy || "Unknown",
    Date.now(),
    "PENDING"
  ];
  sh.appendRow(row);
}

function approve_(submissionId) {
  if (!submissionId) throw new Error("submissionId required");
  const sh = shPending_();
  const values = sh.getDataRange().getValues();
  const idx = index_(values[0]);

  for (let r=1; r<values.length; r++) {
    if (String(values[r][idx.id]) !== String(submissionId)) continue;

    // Move into Approved
    const matchKey = String(values[r][idx.matchKey]);
    const type = values[r][idx.type] || "regular";
    const a = Number(values[r][idx.a]);
    const b = Number(values[r][idx.b]);
    const pairs = safeJsonParse_(values[r][idx.pairsJson] || "[]") || [];
    const sets = sumSetsFromPairs_(pairs);

    upsertApproved_(matchKey, {
      type, a, b,
      aSets: sets.aSets,
      bSets: sets.bSets,
      pairs,
      ts: Date.now()
    });

    // Mark submission approved
    sh.getRange(r+1, idx.status+1).setValue("APPROVED");
    return;
  }
  throw new Error("Submission not found");
}

function reject_(submissionId) {
  if (!submissionId) throw new Error("submissionId required");
  const sh = shPending_();
  const values = sh.getDataRange().getValues();
  const idx = index_(values[0]);

  for (let r=1; r<values.length; r++) {
    if (String(values[r][idx.id]) !== String(submissionId)) continue;
    sh.getRange(r+1, idx.status+1).setValue("REJECTED");
    return;
  }
  throw new Error("Submission not found");
}

/* ---------------- Shared helpers ---------------- */

function sumSetsFromPairs_(pairs){
  let aSets = 0, bSets = 0;
  for (const p of pairs){
    const a = Number(p.aGames);
    const b = Number(p.bGames);
    if (a === 6 && b !== 6) aSets++;
    else if (b === 6 && a !== 6) bSets++;
  }
  return {aSets, bSets};
}

function index_(headerRow){
  const idx = {};
  headerRow.forEach((h,i)=>idx[String(h)] = i);
  return idx;
}

function safeJsonParse_(s){
  try { return JSON.parse(s || "{}"); } catch(e) { return {}; }
}

function json(obj){
  // for ok:true dumps, return obj directly
  const payload = (obj && obj.ok && obj.approved !== undefined) ? obj : obj;
  return ContentService
    .createTextOutput(JSON.stringify(payload))
    .setMimeType(ContentService.MimeType.JSON);
}
